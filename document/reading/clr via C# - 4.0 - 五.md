
线程有空间(内存耗用)和时间(运行时的执行性能)上的开销。

#### 每个线程都有以下要素: ####

- 线程内核对象(thread kernel object)

	OS为系统中创建的每个线程都分配并初始化这种数据结构之一。数据结构包含一组对线程进行描述的属性。数据结构还包含所谓的**线程上下文(thread context)**。上下文是包含CPU寄存器集合的内存块。对于x86、x64和ARM CPU架构，线程上下文分别使用约700,1240和350字节的内存。

- 线程环境块(thread environment block, TEB)

	TEB 是在用户模式(应用程序代码能快速访问的地址空间)中分配和初始化的内存块。TEB耗用1个内存页(x86,x64和ARM CPU中是4KB)。TEB包含线程的**异常处理链首（head）**。线程进入的每个try块都在链首插入一个节点（node）；线程退出try块时从链中删除该节点。此外，TEB还包含**线程的“线程本地存储”数据**，以及由**GDI（Graphics Device Interface， 图形设备接口）和 OpenGL 图形**使用的一些数据结构。

- 用户模式栈(user-mode stack)

	用户模式栈**存储传给方法的局部变量和实参**。它还**包含一个地址**；**指出**当前方法****返回时，线程应该从什么地方接着执行**。Windows默认为每个线程的用户模式栈分配1MB内存。更具体地说，Windows只是保留1MB地址空间，在线程实际需要时才会提交（调拨）物理内存。

- 内核模式栈(kernal-mode stack)

	应用程序代码**向操作系统的内核模式函数传递实参时，还会使用内核模式栈**。出于对安全的考虑，针对**从用户模式的代码传给内核的任何实参**，Windows都会把它们**从线程的用户模式栈复制到线程内核模式栈**。一经复制，内核就可验证实参的值。由于**应用程序代码不能访问内核模式栈**，所以应用程序无法更改验证后的实参值。OS内核代码开始处理复制的值。除此之外，内核会调用它自己内部的方法，并利用内核模式栈传递它的实参、存储函数的局部变量以及存储返回地址。在32位Windows上运行，内核模式栈的大小是12KB；64位Windows是24KB；

- DLL线程连接(attach)和线程分离(detach)通知

	Windows的一个策略是，**任何时候在进程中创建线程**，**都会调用进程中加载的所有非托管DLL的DllMain方法**，**并向该方法传递**DLL_THREAD_ATTACH**标志**。类似地，任何时候线程终止，都会调用进程中的所有非托管DLL的DllMain方法，并传递DLL_THREAD_DETACH标志。有的DLL需要获取这些通知，才能为进程中创建/销毁的每个线程执行特殊的初始化或（资源）清理操作。例如，C-Runtime库的DLL会分配一些线程本地存储状态。线程使用C-Runtime库中包含的函数时需要用到这些状态。


Windows在任何时刻只将一个线程分配给一个CPU。哪个线程能运行一个“时间片”。时间片到期，Windows就上下文切换到另一个线程。

#### 每次上下文切换都要求Windows执行以下操作 ####

1. 将CPU寄存器的值保存到当前正在运行的线程的内核对象内部的一个上下文结构中。
2. 从现有线程集合中选出一个线程供调度。如果该线程由另一个进程拥有，Windows在开始执行任何代码或者接触任何数据之前，还必须切换CPU“看见”的虚拟地址空间。
3. 将所选上下文结构中的值加载到CPU的寄存器中。

----------

1. 什么是托管与非托管？

	托管资源：一般是指被CLR(公共语言运行时)控制的内存资源，这些资源由CLR来管理。可以认为是.net 类库中的资源。
	
	非托管资源：不受CLR控制和管理的资源。
	
	对于托管资源，GC负责垃圾回收。对于非托管资源，GC可以跟踪非托管资源的生存期，但是不知道如何释放它，这时候就要人工进行释放。

2. 哪些资源是非托管的？

	总体来说就是 不受CLR控制和管理的资源
	
	包括：比如文件流、图像图形类、数据库的连接，网络连接，系统的窗口句柄，打印机资源等，这类资源一般不存在堆上。可以认为操作系统资源的一组API。
	
	原则：如果我们的类使用的非托管资源，如数据库连接、文件句柄，这些资源需做到：使用后立刻释放。

#### 使用线程的主要理由 ####

- 可响应性（通常是对于客户端GUI应用程序）

	Windows为每个进程提供它自己的线程，确保发生死循环的应用程序不会妨碍其他应用程序。类似地，在自己的客户端GUI应用程序中，可以将一些工作交给一个线程进行，使GUI线程能灵敏地响应用户输入。在这个过程中创建的线程数可能超过CPU的核数，会浪费系统资源和损害性能。但用户得到了一个响应灵敏的UI，所以应用程序的总体使用体验增强了。

- 性能（对于客户端和服务端应用程序）

	由于Windows每个CPU调度一个线程，而且多个CPU能并发执行这些线程，所以同时执行多个操作能提升性能。当然，只有多CPU（或多核CPU）才能得到性能的提升。


----------

since:6/19/2019 10:52:59 AM 
