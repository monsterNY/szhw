
一个线程池线程阻塞时，线程池会创建额外的线程。

根据异步函数的实现方式，不可能有两个线程**同时**访问相同的数据。所以，在代码访问异步函数中包含的数据时不需要线程同步。

#### 使用锁所带来的问题 ####

1. 比较繁琐，而且很容易写出。

在代码中，必须标识出所有可能由多个线程同时访问的数据。然后，必须用额外的代码将这些代码包围起来，并获取和释放一个线程同步锁。锁的作用是确保一次只有一个线程访问资源。只要有一个代码块忘记用锁包围，数据就会损坏。另外，没有办法证明你已正确添加了所有锁定代码。只能运行应用程序，对它进行大量压力测试，并寄希望于没有什么地方出错。

事实上，应该在CPU(或CPU内核)数量尽可能多的机器上测试应用程序。因为CPU越多，两个或多个线程同时访问资源的几率越大，越容易检测到问题。

2. 它们会损害性能。

获取和释放锁是需要时间的，因为要调用一些额外的方法，而且不同的CPU必须进行协调，以决定哪个线程先取得锁。

让机器中的CPU以这种方式互相通信，会对性能造成影响。

具体慢多少要取决于所选的锁的种类;

3. 一次只允许一个线程访问资源。

这是锁的全部意义之所在，但也是问题之所在，因为阻塞一个线程会造成更多的线程被创建。

例如，假定一个线程池线程试图获取一个它暂时无法获取的锁，线程池就可能创建一个新线程，使CPU保持“饱和”。(创建线程是一个昂贵的操作，会消耗大量内存和时间。)更不妙的是，当阻塞的线程再次运行时，它会和这个新的线程池线程共同运行。也就是说，Windows现在要调度比CPU数量更多的线程，这会增大上下文切换的机率，进一步损害到性能。

#### 基元(primitive) ####

可以在代码中使用的最简单的构造

有两种基元构造： 用户模式(user-mode)和内核模式(kernel-mode)。

应尽量使用基元用户模式构造，它们的速度要显著快于内核模式的构造。(这是因为它们使用了特殊CPU指令来协调线程。这意味着协调是在硬件中发生的)


#### 基元用户模式线程同步构造 ####

- 易变构造(volatile construct)

> 在特定的时间，它在包含一个简单数据类型的变量上执行原子性的读或写操作

- 互锁构造 

> 在特定的时间，它在包含一个简单数据类型的变量上执行原子性的读和写操作。

所有易变和互锁构造都要求传递对包含简单数据类型的一个变量的引用(内存地址)。

#### C#对易变字段的支持 ####

> 易变构造的规则：当线程通过共享内存互相通信时，调用Volatile.Write来写入最后一个值，调用Volatile.Read来读取第一个值。

由于很难记住所有这些方法和规则，并搞清楚其他线程会在后台对共享数据进行什么操作。为了简化编程，C#编译器提供了 volatile关键字。

volatile 关键字告诉C#和JIT编译器不将字段缓存到CPU的寄存器中，确保字段的所有读写操作都在RAM中进行。

#### 互锁构造 ####

System.Threading.Interlocked类中的每个方法都执行一次原子读取以及写入操作。

此外，Interlocked的所有方法都建立了完整的内存栅栏(memory fence)。换言之，调用某个Interlocked方法之前的任何变量写入都在这个Interlocked方法调用之前执行;而这个调用之后的任何变量读取都在这个调用之后读取。



> “自旋”会浪费宝贵的CPU时间，阻止CPU做其他更有用的工作。因此，自旋锁只应该用于保护那些会执行得非常快的代码区域。


- 线程将一直在一个CPU上运行，称为“活锁”
- 线程将一直阻塞，称为“死锁”


> 自旋锁一般不要在单CPU机器上使用，因为在这种机器上，一方面是希望获得锁的线程自旋，一方面是占用锁的线程不能快速释放锁。

> 如果占有锁的线程的优先级低于想要获取锁的线程，会导致占有锁的线程可能根本没机会运行。从而导致“活锁”

### 内核模式构造 ###

> 内核模式的构造比用户模式的构造慢得多，
> 
> 一个原因是它们要求Windows操作系统自身的配合，
> 
> 另一个原因是**在内核对象上调用的每个方法都造成调用线程从托管代码转换为本机(native)用户模式代码，**
> 
> **再转换为本机(native)内核模式代码。**
> 
> 然后，还要朝相反的方向一路返回。
> 
> 这些转换需要大量CPU时间;
> 
> 经常会对应用程序的总体性能造成负面影响。


#### 内核模式的构造具备基元用户模式构造所不具备的优点： ####

- 内核模式的构造检测到在一个资源上的竞争时，Windows会阻塞输掉的线程，使它不占着一个CPU“自旋”(spinning)，无谓地浪费处理器资源。
- 内核模式的构造可实现本机（native）和托管（managed）线程互相之间的同步
- 内核模式的构造可同步在同一台机器的不同进程中运行的线程。
- 内核模式的构造可应用安全性设置，防止未经授权的账户访问它们。
- 线程可一直阻塞，直到集合中的所有内核模式构造都可用，或直到集合中的任何内核模式构造可用。
- 在内核模式的构造上阻塞的线程可指定超时值；指定时间内访问不到希望的资源，线程就可以解除阻塞并执行其他任务。

事件和信号量是两种基元内核模式线程同步构造。至于其他内核模式构造，比如互斥体，则是在这两个基元构造上构建的。

----------

windows不是实时操作系统


- Thread.Sleep

> 让线程退出,回收它的栈和内核对象。可以**向Sleep传递0**，告诉系统调用线程放弃了它当前时间片的剩余部分，强迫系统调度另外一个线程。但系统可能重新调度刚才调用了Sleep的线程(如果没有相同或更高优先级的其他可调度线程，就会发生这种情况。)

	public static void Sleep(Int32 millisecondsTimeout);

	public static void Sleep(TimeSpan timeout);

- Thread.Yield

> 线程可要求Windows在当前CPU上调度另一个线程，这是通过**Thread的Yield方法**

> 如果Windows发现有另一个线程准备好在当前处理器上运行,Yield就会返回true,
> 
> 调用Yield的线程会提前结束它的时间片，所选的线程得以运行一个时间片。
> 
> 然后，调用Yield的线程被再次调度，开始用一个全新的时间片运行。
> 
> 如果Windows发现没有其他线程准备在当前处理器上运行，Yield就会返回false，调用Yield的线程继续运行它的时间片。

> Yield方法旨在使“饥饿”状态的、具有相等或更低优先级的线程有机会运行。

	public static bool Yield();

- Yield VS Sleep

> 调用Yield的效果介于调用Thread.Sleep(0)和Thread.Sleep(1)之前。

> **Thread.Sleep(0)**不允许较低优先级的线程运行，
> 
> 而**Thread.Sleep(1)**总是强迫进行上下文切换，
> 
> 而由于内部系统计时器的解析度的问题，Windows总是强迫线程睡眠超过1毫秒的时间。

- 超线程CPU

> 超线程CPU一次只允许一个线程运行。
> 
> 所以，在这些CPU上执行“自旋”循环时，需要强迫当前线程暂停，使CPU有机会切换到另外一个线程并允许它运行。
> 
> 线程可调用**Thread的SpinWait**方法**强迫它自身暂停**,允许超线程CPU切换到另外一个线程

	public static void SpinWait(Int32 iterations)

> 调用这个方法实际会执行一个特殊的CPU指令;它不告诉Windows做任何事情(因为Windows已经认为它在CPU上调度了两个线程)。
> 
> 在非超线程CPU上，这个特殊CPU指令会被忽略。

----------

since:6/24/2019 4:49:31 PM 

update:6/25/2019 10:09:32 AM 