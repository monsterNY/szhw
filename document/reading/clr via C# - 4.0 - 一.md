


> IL:一种面对对象的机器语言

执行方法时，需要将方法的IL转换为本机CPU指令

这正是CLR JIT 的职责

> 概念词

- 枚举
- 数组
- 属性
- 索引器
- 委托
- 事件
- 构造器
- 终结器、析构函数
- 操作符重载
- 转换操作符

编译器直接支持的数据类型称为基元类型


----------

#### 引用类型和值类型 ####

1. 内存必须从托管堆分配。
2. 堆上分配的每个对象都有一些额外成员(类型指针和同步索引块)，这些成员必须初始化
3. 对象中的其他字节(为字段而设)总是设为零。
4. 从托管堆分配对象时，可能强制执行一次回收

#### 装箱 ####

> 过程：

1. 在托管堆中分配内存。分配的内存量是值类型各字段所需的内存量，还要加上托管堆所有对象都有的两个额外成员(类型对象指针和同步索引块)所需的内存量。
2. 值类型的字段**复制**到新分配的堆内存。
3. 返回对象地址。

#### 拆箱 ####

> 拆箱其实就是获取指针的过程，该指针指向包含在一个对象中的原始值类型(数据字段)。其实，指针指向的是已装箱实例中的未装箱部分。
> 
> 所以和装箱不同，拆箱不要求在内存中复制任何字节

一次拆箱操作经常紧接着一次字段复制。

	一次拆箱过后，一般会申明一个变量接收拆箱后的结果

	于是在接收过程中，需要生成IL指令将这些字段从堆复制到基于栈的变量中。 

过程

1. is null 检查
2. cast 检查 ， 类型检查

$语法糖需要进行装箱，实际使用format

用基类（例如object）的方法时 需要进行装箱(注：虚方法若已重写则不需要)

typeof(结构) 不进行装箱，IL:

	IL_005b: ldtoken[System.Runtime]System.Int32
	IL_0060:  call       class [System.Runtime]
	System.Type[System.Runtime] System.Type::GetTypeFromHandle(valuetype[System.Runtime] System.RuntimeTypeHandle)

未装箱实例转换为接口时需要装箱

#### 相等性实现 ####

	bool Equals(object obj)

1. 如果obj为null返回false
2. 如果this 与 obj为引用同一对象 返回true
3. this 与 obj 引用对象的类型不同 返回false
4. 将this与obj对象中的每个值进行比较,不同则返回false
5. 调用基类的Equals方法来比较它定义的任何字段。



----------

note:

类型构造器：

	static class_name(){
		do something...
	}

> string的拼接实际上使用了concat方法。
> 
> 默认调用Concat(object,object,...) 存在装箱处理

> 由于未装箱值类型没有同步块索引，所以不能使用lock.

> 检查同一性应使用Object的ReferenceEquals。避免==重载

> == 用于相等性。

#### CLR 调用指令 ####

- call

	该IL指令可调用静态方法、实例方法和虚方法。用call指令调用静态方法，必须指定方法的定义类型。
	即该指令通过对象类型(Type)调用
	若该对类型没有此方法则检查基类型来查看匹配方法。

	调用实例方法或虚方法时，必须指定引用了对象的变量。

	call指令假定该变量不为null。

- callvirt

	该IL指令可调用实例方法和虚方法，不能调用静态方法。用callvirt指令调用实例方法或虚方法，必须指定引用了对象的变量。

	调用非虚方法时，变量的类型指明了方法的定义类型。

	调用虚方法时，CLR调查发出调用对象的实际类型，然后以多态方式调用方法。

	为了确定类型，发出调用的变量绝不能为null。即编译这个调用时，JIT编译器会生成代码来验证变量的值是否为null。

	注：即便是非虚方法,也要执行null检查

由于callvirt存在null检查,callvirt性能不及call

在调用密封类的虚方法时，可采用非虚方式调用虚方法。

常量视为类型定义的一部分。即总是视为静态成员

定义常量将导致创建元数据

#### 匿名类型 ####

匿名类型(new {prop=value,...})声明不可变(immutable)的元组类型。

除了创建推断类型的字段外，编译器还会重写Object的Equals,GetHashCode和ToString方法。

其中Equals 实现为 任何字段不匹配就返回false，否则返回true

#### 接口 ####

使用接口约束会避免装箱操作，例如：

	public void Run<T>(T t) where T:Ixxx
	{
		t.method();//若t为值类型此处不产生装箱
	}

> C#编译器为接口约束生成特殊IL指令,导致直接在值类型上调用接口方法而不装箱。

#### string ####

String是引用类型，一个String代表一个不可变(immutable)的顺序字符集。

用于构建对象新实例的IL指令是newobj.

但用于构建string的却是ldstr(load string)指令，例如 ：

	String str = "xxx";

若使用new String(..)构建 还是通过newobj指令

> 虽然在字符串中硬编码了回车符和换行符，但一般不建议这样做。

> System.Environment类型定义了只读NewLine属性。应用程序在Microsoft Windows上运行时，该属性返回由回车符和换行符构成的字符串。

> NewLine属性对平台敏感，会根据底层平台来返回恰当的字符串。

字符串拼接时,若所有字符串都是字面值，例如：

	"123"+","+"456

C#编译器直接在编译时连接他们。

> 字符串是不可变的。

> 字符串不可变意味在操纵或访问字符串时不会发生线程同步问题。此外，CLR可通过一个string对象共享多个完全一致的String内容。从而减少系统中字符串数量-->从而节省内存-->这就是所谓的"字符串留用"(string interning)

#### 字符串留用(string interning) ####

CLR初始化时会创建一个内部哈希表.在这个表中,key是字符串,value是对托管堆中的String对象的引用。

相关访问方法:

	public static string Intern(string str)

	public static string IsInterned(string str)

第一个方法获取一个String，获取他的哈希码，在内部哈希表中检查是否有相匹配的。如果存在则返回现有String对象的引用。不存在则创建字符串的副本，将副本添加到内部哈希表中，返回对该副本的引用。

如果应用程序不再保持对原始String对象的引用，垃圾回收器就可释放哪个字符串的内存。

注：GC无法释放内部哈希表引用的字符串，除非卸载AppDomain或进程终止。

CLR 4.5 以上版本默认对字面值进行留用

#### 字符串池 ####

编译源代码时，编译器必须处理每个字面值(literal)字符串，并在托管模块的元数据中嵌入。同一个字符串在源代码中多次出现，把他们都嵌入元数据会使生成的无谓地增大。

fix:在模块的元数据中只将字面值字符串写入一次。引用该字符串的所有代码都被修改成引用元数据中的同一字符串。编译器将单个字符串的多个实例合并成一个实例，能显著减少模块的大小。

----------
since:  6/10/2019 11:19:43 AM 

update: 6/11/2019 11:11:04 AM

update: 6/12/2019 9:36:08 AM  

direction:reading

source:CLR via C#(第四版)