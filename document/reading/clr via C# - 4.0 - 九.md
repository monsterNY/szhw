
## 混合线程同步构造 ##

> 一般合并了用户模式和内核模式构造，称之为**混合线程同步构造**。没有线程竞争时，混合模式构造提供了基元用户模式构造所具有的性能优势。多个线程竞争一个构造时，混合构造通过基元内核模式的构造来提供不“自旋”的优势(避免浪费CPU时间)。

### 自旋、线程所有权和递归 ###

> 由于转换为内核模式会造成巨大的性能损失，而且线程占有锁的时间通常都很短，所以为了提升应用程序的总体性能，可以让一个线程在用户模式“自旋”一小段时间，再让线程转换为内核模式。如果线程正在等待的锁在线程“自旋”期间变得可用，就能避免向内核模式的转换。

### Monitor类和同步块 ###

Monitor 是一个混合型线程同步构造

> 它提供了支持自旋、线程所有权和递归的互斥锁。


堆中的每个对象都可关联一个名为**同步块**的数据结构。

> 显然，为堆中每个对象都关联一个同步块数据结构显得很浪费，尤其是考虑到大多数对象的同步块都从不使用。

> 为节省内存，CLR初始化时在堆中分配一个同步块数组。

> 一个对象在构造时，它的同步块索引初始化为-1，表明不引用任何同步块。
> 
> 然后，调用Monitor.Enter时，
> 
> CLR在数组中找到一个空白同步块，并设置对象的同步块索引，让它引用该同步块。
> 
> 换言之，**同步块和对象是动态关联的**。
> 
> 调用Exit时，
> 
> 会检查是否有其他任何线程正在等待使用对象的同步块。
> 
> 如果没有线程在等待它，同步块就自由了，Exit将对象的同步块索引设回**-1**，
> 
> 自由的同步块将来可以和另外一个对象关联。

如有必要，同步块数组能创建更多的同步块。所以，同时同步大量对象时，不必担心系统会用光同步块。

#### Monitor存在的问题 ####

- 锁定的是代理对象而不是代理引用的实际对象

> 变量能引用一个代理对象
> 
> 》》前提是变量引用的那个对象的类型派生自System.MarshalByRefObject 类(参见"CLR寄宿和AppDomain")。
> 
> 调用Monitor的方法时，传递对代理对象的引用，锁定的是代理对象而不是代理引用的实际对象。


- 永远不要向Monitor的方法传递对象类型引用

> 如果线程调用 Monitor.Enter ，
> 
> 向它传递对类型对象的引用，而且这个类型对象是以“AppDomain中立”的方式加载的，
> 
> 线程就会跨越进程中的所有AppDomain在哪个类型上获取锁。
> 
> 这是CLR一个已知的bug,它破坏了AppDomain 本应提供的隔离能力。这个 bug 很难在保证高性能的前提下修复，所以它一直没有修复。

- 永远不要将String引用传给Monitor的方法。

> 由于字符串可以留用，所以两个完全独立的代码段可能在不知情的情况下获取对内存中的一个 String 对象的引用。
> 
> 如果将这个 String 对象引用传给 Monitor的方法，两个独立的代码段现在就会在不知情的情况下开始同步。建议：

-永远不要传递值类型

> 由于Monitor的方法要获取一个Object,所以传递值类型会导致值类型被装箱，造成线程在已装箱对象上获取锁。
> 
> 每次调用Monitor.Enter 都会在一个完全不同的对象上获取锁，造成完全无法实现线程同步。

- 永远不要使用MethodImplAttribute特性。

> 向方法应用**[MethodImpl(MethodImplOptions.Synchronized)]**特性，会造成JIT编译器用**Monitor.Enter**和**Monitor.Exit**调用方法的本机代码。
> 
> 如果方法是实例方法，会将this传给Monitor的这些方法，锁定隐式公共的锁。
> 
> 如果方法是静态的，对类型的类型对象的引用会传给这些方法，造成锁定“AppDomain中立”的类型。


- 尽量避免使用类型构造器，或者至少保持它们短小和简单。

> 调用类型的类型构造器时，CLR要获取类型对象上的一个锁，确保只有一个线程初始化类型对象及其静态字段。
> 
> 同样地，这个类型可能以**“AppDomain中立”**的方式加载，所以会出问题。
> 
> 例如，假定类型构造器的代码进入死循环，进程中的所有AppDomain都无法使用该类型。

### 异步的同步构造 ###

#### 与大多数构造相比，任务具有下述许多优势 ####

- 任务使用的内存比线程少得多，创建和销毁所需的时间也少得多。


- 线程池根据可用CPU数量自动伸缩任务规模。


- 每个任务完成一个阶段后，运行任务的线程回到线程池，在那里能接受新任务。


- 线程池是站在整个进程的高度观察任务。所以，它能更好的调度这些任务，减少进程中的线程数，并减少上下文切换。

----------
since:6/26/2019 11:07:26 AM 