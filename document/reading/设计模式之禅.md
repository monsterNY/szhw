
## 单一职责-SRP(Single Responsibility Principle) ##

单一职责原则的定义是：应该有且仅有一个原因引起类的变更。

> There should never be more than one reason for a class to change.

## 里氏替换原则（Liskov Substitution Principle，LSP） ##

- 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of
type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is
substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对
象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变
化，那么类型S是类型T的子类型。）

- 第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且
替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但
是，反过来就不行了，有子类出现的地方，父类未必就能适应。

## 依赖倒置原则（Dependence Inversion Principle,DIP） ##

> High level modules should not depend upon low level modules.Both should depend upon
abstractions.Abstractions should not depend upon details.Details should depend upon abstractions

翻译过来，包含三层含义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
- 抽象不应该依赖细节；
- 细节应该依赖抽象。

采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风
险，提高代码的可读性和可维护性

依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，
不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几
个规则就可以：

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。
- 变量的表面类型尽量是接口或者是抽象类
很多书上说变量的类型一定要是接口或者是抽象类，这个有点绝对化了，比如一个工具
类，xxxUtils一般是不需要接口或是抽象类的。还有，如果你要使用类的clone方法，就必须
使用实现类，这个是JDK提供的一个规范。
- 任何类都不应该从具体类派生
如果一个项目处于开发状态，确实不应该有从具体类派生出子类的情况，但这也不是绝
对的，因为人都是会犯错误的，有时设计缺陷是在所难免的，因此只要不超过两层的继承都
是可以忍受的。特别是负责项目维护的同志，基本上可以不考虑这个规则，为什么？维护工
作基本上都是进行扩展开发，修复行为，通过一个继承关系，覆写一个方法就可以修正一个
很大的Bug，何必去继承最高的基类呢？（当然这种情况尽量发生在不甚了解父类或者无法
获得父类代码的情况下。）
- 尽量不要覆写基类的方法
如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是
抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。
- 结合里氏替换原则使用
在第2章中我们讲解了里氏替换原则，父类出现的地方子类就能出现，再结合本章的讲
解，我们可以得出这样一个通俗的规则： 接口负责定义public属性和方法，并且声明与其他
对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适
当的时候对父类进行细化。

#### 什么是高内聚？ ####

高内聚就是提高接口、类、模块的处理能力，减少对外的交互。比如你
告诉下属“到奥巴马的办公室偷一个×××文件”，然后听到下属用坚定的口吻回答你：“是，保
证完成任务！”一个月后，你的下属还真的把×××文件放到你的办公桌上了，这种不讲任何条
件、立刻完成任务的行为就是高内聚的表现。具体到接口隔离原则就是，要求在接口中尽量
少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越
少，同时也有利于降低成本