
#### 访问资源的步骤 ####

1. 调用IL指令newobj,为代表资源的类型分配内存(一般使用C#new操作符来完成)
2. 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。
3. 访问类型的成员来使用资源 
4. 摧毁资源的状态以进行清理。
5. 释放内存。垃圾回收器独自负责这一步。

#### C# new 操作符导致CLR执行的步骤： ####

1. 计算类型的字段(包含从基类继承的字段)所需的字节数
2. 加上对象的开销所需的字节数。每个对象都有两个字段开销：类型对象指针和同步块索引。对于32位应用程序，这两个字段各自需要32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各需要64位，所以每个对象要增加16字节
3. CLR检查区域中是否分配对象的字节数。如果托管堆有足够的可用空间，就在NextObjPtr指针指向的地址处放入对象，为对象分配的字节会被清零。接着调用类型的构造器(为this参数传递NextObjPtr),new操作符返回对象引用。就在返回这个引用之前，NextObjPtr指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。

> CLR要求所有对象都从托管堆分配(特殊的string)

> 进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还要维护一个指针，我把它称作NextObjPtr。该指针指向下一个对象在堆中的分配位置。刚开始的时候，NextObjPtr设为地址空间区域的基地址

> 使用C#编译器的/debug开关编译程序集时，编译器会应用System.Diagnostics.DebuggableAttribute,并为结果程序集设置DebuggingModes的DisableOptimizations标志。运行时编译方法时，JIT编译器看到这个标志，**会将所有根的生存期延长至方法结束。**

**测试GC回收需使用Release编译查看效果...**

#### 垃圾回收算法 ####

**引用计数**(Microsoft自己的“组件对象模型”(Component Object Model, COM)使用的就是此算法)

> 在这种系统中，堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一个“部分”到达代码中某个不再需要对象的地方，就递减对象的计数字段。计数字段变成0，对象就可以从内存中删除。

> 许多引用计数系统最大的问题是处理不好循环引用。例如在GUI应用程序中，窗口将容纳对子UI元素的引用，而子UI元素将容纳对父窗口的引用。这种引用会阻止两个对象的计数器达到0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口了。

鉴于引用计数垃圾回收器算法存在的问题，CLR改为使用一种**引用跟踪算法**

> 引用跟踪算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象；

> 我们将所有引用类型的变量称为根。

> CLR开始GC时，首先暂停进程中的所有线程。从而防止线程在CLR检查期间访问对象并更改其状态。然后,CLR进入GC的**标记**阶段。

> 在这个阶段，CLR遍历堆中的所有对象，将同步索引字段中的一位设为0。这表明所有对象都应删除。然后，CLR检查所有活动根,查看他们引用了哪些对象。这正是CLR的GC称为引用跟踪GC的原因。如果一个根包含null,CLR忽略这个根并继续检查下个根。

> 任何根如果引用了堆上的对象，CLR都会标记哪个对象，也就是将该对象的同步块索引中的位设为1.一个对象被标记后，CLR会检查哪个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。从而避免了因为循环引用而产生的死循环。

#### 代：提升性能 ####

> 垃圾回收器会检查有多少内存被回收，以及有多少对象幸存。基于这些结果，垃圾回收器可能增大或减小这些代的预算，从而提升应用程序的总体性能。

> 最终的结果是，垃圾回收器会根据应用程序要求的内存负载来自动化

#### 大对象 ####

目前认为85000字节或更大的对象是大对象 

- 大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配
- 目前版本的GC不压缩大对象，因为在内存中移动它们代价过高。但这可能在进程中的大对象之间造成地址空间的碎片化
- 大对象总是第二代。

#### Finalize ####

包含本机资源的类型被GC时，GC会回收对象在托管堆中使用的内存。但这样会造成本机资源(GC对它一无所知)的泄漏。

所以，CLR提供了称为终结(Finalization)的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。

终极基类System.Object定义了受保护的虚方法Finalize。垃圾回收器判定对象是垃圾后，会调用对象的Finalize方法（如果重写）。Microsoft的C#团队认为Finalize在编程语言中需要特殊语法(类似于C#要求特殊语法定义结构)。因此,**C#要求在类名前添加~符合来定义Finalize方法。**

----------
since:6/14/2019 9:55:30 AM 

source:clr via C# - 4.0