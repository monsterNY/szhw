
#### 访问资源的步骤 ####

1. 调用IL指令newobj,为代表资源的类型分配内存(一般使用C#new操作符来完成)
2. 初始化内存，设置资源的初始状态并使资源可用。类型的实例构造器负责设置初始状态。
3. 访问类型的成员来使用资源 
4. 摧毁资源的状态以进行清理。
5. 释放内存。垃圾回收器独自负责这一步。

#### C# new 操作符导致CLR执行的步骤： ####

1. 计算类型的字段(包含从基类继承的字段)所需的字节数
2. 加上对象的开销所需的字节数。每个对象都有两个字段开销：类型对象指针和同步块索引。对于32位应用程序，这两个字段各自需要32位，所以每个对象要增加8字节。对于64位应用程序，这两个字段各需要64位，所以每个对象要增加16字节
3. CLR检查区域中是否分配对象的字节数。如果托管堆有足够的可用空间，就在NextObjPtr指针指向的地址处放入对象，为对象分配的字节会被清零。接着调用类型的构造器(为this参数传递NextObjPtr),new操作符返回对象引用。就在返回这个引用之前，NextObjPtr指针的值会加上对象占用的字节数来得到一个新值，即下个对象放入托管堆时的地址。

> CLR要求所有对象都从托管堆分配(特殊的string)

> 进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还要维护一个指针，我把它称作NextObjPtr。该指针指向下一个对象在堆中的分配位置。刚开始的时候，NextObjPtr设为地址空间区域的基地址

> 使用C#编译器的/debug开关编译程序集时，编译器会应用System.Diagnostics.DebuggableAttribute,并为结果程序集设置DebuggingModes的DisableOptimizations标志。运行时编译方法时，JIT编译器看到这个标志，**会将所有根的生存期延长至方法结束。**

**测试GC回收需使用Release编译查看效果...**

#### 垃圾回收算法 ####

**引用计数**(Microsoft自己的“组件对象模型”(Component Object Model, COM)使用的就是此算法)

> 在这种系统中，堆上的每个对象都维护着一个内存字段来统计程序中多少“部分”正在使用对象。随着每一个“部分”到达代码中某个不再需要对象的地方，就递减对象的计数字段。计数字段变成0，对象就可以从内存中删除。

> 许多引用计数系统最大的问题是处理不好循环引用。例如在GUI应用程序中，窗口将容纳对子UI元素的引用，而子UI元素将容纳对父窗口的引用。这种引用会阻止两个对象的计数器达到0，所以两个对象永远不会删除，即使应用程序本身不再需要窗口了。

鉴于引用计数垃圾回收器算法存在的问题，CLR改为使用一种**引用跟踪算法**

> 引用跟踪算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象；

> 我们将所有引用类型的变量称为根。

> CLR开始GC时，首先暂停进程中的所有线程。从而防止线程在CLR检查期间访问对象并更改其状态。然后,CLR进入GC的**标记**阶段。

> 在这个阶段，CLR遍历堆中的所有对象，将同步索引字段中的一位设为0。这表明所有对象都应删除。然后，CLR检查所有活动根,查看他们引用了哪些对象。这正是CLR的GC称为引用跟踪GC的原因。如果一个根包含null,CLR忽略这个根并继续检查下个根。

> 任何根如果引用了堆上的对象，CLR都会标记哪个对象，也就是将该对象的同步块索引中的位设为1.一个对象被标记后，CLR会检查哪个对象中的根，标记它们引用的对象。如果发现对象已经标记，就不重新检查对象的字段。从而避免了因为循环引用而产生的死循环。

#### 代：提升性能 ####

> 垃圾回收器会检查有多少内存被回收，以及有多少对象幸存。基于这些结果，垃圾回收器可能增大或减小这些代的预算，从而提升应用程序的总体性能。

> 最终的结果是，垃圾回收器会根据应用程序要求的内存负载来自动化

#### 大对象 ####

目前认为85000字节或更大的对象是大对象 

- 大对象不是在小对象的地址空间分配，而是在进程地址空间的其他地方分配
- 目前版本的GC不压缩大对象，因为在内存中移动它们代价过高。但这可能在进程中的大对象之间造成地址空间的碎片化
- 大对象总是第二代。

#### Finalize ####

包含本机资源的类型被GC时，GC会回收对象在托管堆中使用的内存。但这样会造成本机资源(GC对它一无所知)的泄漏。

所以，CLR提供了称为终结(Finalization)的机制，允许对象在被判定为垃圾之后，但在对象内存被回收之前执行一些代码。

终极基类System.Object定义了受保护的虚方法Finalize。垃圾回收器判定对象是垃圾后，会调用对象的Finalize方法（如果重写）。Microsoft的C#团队认为Finalize在编程语言中需要特殊语法(类似于C#要求特殊语法定义结构)。因此,**C#要求在类名前添加~符合来定义Finalize方法。**

> 被视为垃圾的对象在垃圾回收完毕后才调用Finalize方法，所以这些对象的**内存并不是马上被回收**,因为Finalize方法可能要执行访问字段的代码。可终结对象在回收时必须存活，造成它被提升到另一代，**使对象活得比正常时间长**。这 **增大了内存耗用**，所以应尽可能避免终结。更糟的是，可终结对象被提升时，其字段引用的所有对象也会被提升，因为他们也必须继续存活。所以， **要尽量避免为引用类型的字段定义可终结对象。**

> 另外，Finalize方法的 **执行时间是控制不了的**。 应用程序请求更多内存时才可能发生GC, 而 **GC完成后才运行Finalize。** 另外， **CLR不保证多个Finalize方法的调用顺序。** 所以，在Finalize方法中不要访问定义了Finalize方法的其他类型的对象;

> CLR用一个特殊的、高优先级的专用线程调用Finalize方法来避免死锁。如果Finalize方法阻塞(例如进入死循环，或等待一个永远不发出信号的对象)，该特殊线程就调用不了任何更多的Finalize方法。这是非常坏的情况，因为应用程序永远回收不了可终结对象占用的内存——只要应用程序运行就会一直泄漏内存。

> **如果Finalize方法抛出未处理的异常，则进程终止，没办法捕捉该异常。**

> 替代：创建封装了本机资源的托管类型时，应该先从System.Runtime.InteropServices.SafeHandle这个特殊基类派生出一个类。

----------
since:6/14/2019 9:55:30 AM 

update:6/18/2019 10:00:40 AM 

source:clr via C# - 4.0