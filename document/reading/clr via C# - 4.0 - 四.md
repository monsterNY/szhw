
> 当一个对象不可达时，垃圾回收器就把它视为垃圾。但是，当垃圾回收器将对象的引用从终结列表移至freachable队列时，对象不再被认为是垃圾，不能回收它的内存。对象被视为垃圾又变得不是垃圾，我们说对象被复活了。

![初版示例图](https://i.imgur.com/GgHzEYf.png)

![123](https://i.imgur.com/pV8al9b.png)

> 为了监控或监视对象的生存期，可调用**GCHandle**的静态**Alloc**方法并传递想控制/监视的对象的引用。还可以传递一个 **GCHandleType**，这是一个标志，指定了你想如何控制/监视对象。

#### GCHandleType枚举值说明： ####

- Weak

	该标志允许监视对象的生存期。

	具体地说，可检测垃圾回收器在什么时候判定该对象在应用程序代码中不可达。注意，此时对象的Finalize方法可能执行，也可能没执行，对象可能还在内存中

	此句柄类型用于跟踪对象，但允许回收该对象。 当回收某个对象时，GCHandle 的内容归零。 在终结器运行之前，Weak 引用归零，因此即使终结器使该对象复活，Weak 引用仍然是归零的。

- WeakTrackResurrection

	该标志允许监视对象的生存期。

	具体的说，可检测垃圾回收器在什么时候判定该对象在应用程序的代码中不可达。注意，此时对象的Finalize方法(如果存在)已经执行，对象的内存已经被回收

	该句柄类型类似于 Weak，但如果对象在终结过程中复活，此句柄不归零。

- Normal

	该标志允许控制对象的生存期。

	具体的说，是告诉垃圾回收器：即使应用程序中没有变量(根)引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存可以压缩(移动)。不向Alloc方法传递任何GCHandleType标志，就默认使用GCHandleType.Normal

	此句柄类型表示不透明句柄，这意味着无法通过此句柄解析固定对象的地址。 可以使用此类型跟踪对象，并防止它被垃圾回收器回收。 当非托管客户端持有对托管对象的唯一引用（从垃圾回收器检测不到该引用）时，此枚举成员很有用。

- Pinned

	该标志允许控制对象的生存期。

	具体的说，是告诉垃圾回收器：即使应用程序中没有变量(根)引用该对象，该对象也必须留在内存中。垃圾回收发生时，该对象的内存不能压缩(移动)。需要将内存地址交给本机代码时，这个功能很好用。本机代码知道GC不会移动对象，所以能放心的向托管堆的这个内存写入。

	此句柄类型类似于 Normal，但允许使用固定对象的地址。 这将防止垃圾回收器移动对象，因此将降低垃圾回收器的效率。 使用 Free() 方法可尽快释放已分配的句柄。

#### 垃圾回收器如何使用GC句柄表。 ####

1. 垃圾回收器标记所有可达的对象。然后，垃圾回收器扫描GC句柄表；所有Normal或Pinned对象都被看成是根，同时标记这些对象(包括这些对象通过它们的字段引用的对象)
2. 垃圾回收器扫描GC句柄表，查找所有Weak记录项。如果一个Weak记录项引用了未标记的对象，该引用标识的就是不可达对象(垃圾)，该记录项的引用值更改为null。
3. 垃圾回收器扫描终结列表。在列表中，对未标记对象的引用标识的是不可达对象，这些引用从终结列表移至freachable队列。这时对象会被标记，因为对象又变成可达了。
4. 垃圾回收器扫描GC句柄表，查找所有WeakTrackResurrection记录项。如果一个WeakTrackResurrection记录项引用了未标记的对象(它现在是由freachable队列中的记录项引用的)，该引用标识的就是不可达对象(垃圾)，该记录项的引用值更改为null。
5. 垃圾回收器对内存进行压缩，填补不可达对象留下的内存“空洞”，这其实就是一个内存碎片化整理的过程。Pinned对象不会压缩(移动)，垃圾回收器会移动它周围的其他对象。


----------

reachable-可达的

f-finalize 终结

----------
since:6/18/2019 11:36:43 AM 
