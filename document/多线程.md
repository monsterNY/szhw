
# 多线程 #

- 什么是线程？

	> 线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

	> 线程是操作系统能够进行运算调度的最小单位，单核CPU电脑同一时间内只能执行一个线程

- 为什么要使用多线程

	> 具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。

	> 因有硬件支持(多核CPU)，可以在同一时间执行多个线程(参考并行)，从而提升系统的处理性能，提升系统的响应速度。

- 一个线程有哪些开销？(线程包含要素)

	1. 线程内核对象(thread kernel object)
	
		> OS为系统中创建的每个线程都分配并初始化这种数据结构之一。数据结构包含一组对线程进行描述的属性。数据结构还包含所谓的**线程上下文(thread context)**。上下文是包含CPU寄存器集合的内存块。对于x86、x64和ARM CPU架构，线程上下文分别使用约700,1240和350字节的内存。
	
	2. 线程环境块(thread environment block, TEB)
	
		> TEB 是在用户模式(应用程序代码能快速访问的地址空间)中分配和初始化的内存块。TEB耗用1个内存页(x86,x64和ARM CPU中是4KB)。TEB包含线程的**异常处理链首（head）**。线程进入的每个try块都在链首插入一个节点（node）；线程退出try块时从链中删除该节点。此外，TEB还包含**线程的“线程本地存储”数据**，以及由**GDI（Graphics Device Interface， 图形设备接口）和 OpenGL 图形**使用的一些数据结构。
	
	3. 用户模式栈(user-mode stack)
	
		> 用户模式栈**存储传给方法的局部变量和实参**。它还**包含一个地址**；**指出**当前方法****返回时，线程应该从什么地方接着执行**。Windows默认为每个线程的用户模式栈分配1MB内存。更具体地说，Windows只是保留1MB地址空间，在线程实际需要时才会提交（调拨）物理内存。
	
	4. 内核模式栈(kernal-mode stack)
	
		> 应用程序代码**向操作系统的内核模式函数传递实参时，还会使用内核模式栈**。出于对安全的考虑，针对**从用户模式的代码传给内核的任何实参**，Windows都会把它们**从线程的用户模式栈复制到线程内核模式栈**。一经复制，内核就可验证实参的值。由于**应用程序代码不能访问内核模式栈**，所以应用程序无法更改验证后的实参值。OS内核代码开始处理复制的值。除此之外，内核会调用它自己内部的方法，并利用内核模式栈传递它的实参、存储函数的局部变量以及存储返回地址。在32位Windows上运行，内核模式栈的大小是12KB；64位Windows是24KB；
	
	5. DLL线程连接(attach)和线程分离(detach)通知
	
		> Windows的一个策略是，**任何时候在进程中创建线程**，**都会调用进程中加载的所有非托管DLL的DllMain方法**，**并向该方法传递**DLL_THREAD_ATTACH**标志**。类似地，任何时候线程终止，都会调用进程中的所有非托管DLL的DllMain方法，并传递DLL_THREAD_DETACH标志。有的DLL需要获取这些通知，才能为进程中创建/销毁的每个线程执行特殊的初始化或（资源）清理操作。例如，C-Runtime库的DLL会分配一些线程本地存储状态。线程使用C-Runtime库中包含的函数时需要用到这些状态。


- 多线程有什么缺点或隐患？

	1. 程序设计更加复杂：线程通讯与多线程的数据共享。
	2. 创建线程是开销是非常大的
	3. 线程安全
	

- 如何处理这些缺点或隐患？

1. 线程池

> 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。
> 
> 任务调度以执行线程的常见方法是使用同步队列，称作任务队列。池中的线程等待队列中的任务，并把执行完的任务放入完成队列中。
		
线程池模式一般分为两种：HS/HA半同步/半异步模式、L/F领导者与跟随者模式。

- 半同步/半异步模式又称为生产者消费者模式，是比较常见的实现方式，比较简单。分为同步层、队列层、异步层三层。同步层的主线程处理工作任务并存入工作队列，工作线程从工作队列取出任务进行处理，如果工作队列为空，则取不到任务的工作线程进入挂起状态。由于线程间有数据通信，因此不适于大数据量交换的场合。

- 领导者跟随者模式，在线程池中的线程可处在3种状态之一：领导者leader、追随者follower或工作者processor。任何时刻线程池只有一个领导者线程。事件到达时，领导者线程负责消息分离，并从处于追随者线程中选出一个来当继任领导者，然后将自身设置为工作者状态去处置该事件。处理完毕后工作者线程将自身的状态置为追随者。这一模式实现复杂，但避免了线程间交换任务数据，提高了CPU cache相似性。在ACE(Adaptive Communication Environment)中，提供了领导者跟随者模式实现。

线程池的伸缩性对性能有较大的影响。

- 创建太多线程，将会浪费一定的资源，有些线程未被充分使用。
- 销毁太多线程，将导致之后浪费时间再次创建它们。
- 创建线程太慢，将会导致长时间的等待，性能变差。
- 销毁线程太慢，导致其它线程资源饥饿。

2.线程同步

(....) 



----------

### 调度 ###

调度算法

- 先来先服务（First Come First Served，FCFS ）
- 最短作业（进程）优先（SJF：Shortest Job First
- SPF：Shortest Process First）
- 响应比最高者优先算法（HRRF:Highest Response Ratio First）
- 优先级调度算法
- 时间片轮转调度算法(Round Robin，RR)
- 多级反馈队列调度算法（MLFQ：Multi-level Feedback Queue）

现在所有的桌面操作系统和服务器操作系统都是使用抢占式调度。但像手机这种小型设备使用写作式调度，这样时，一个线程只有调用了yield方法或阻塞或等待时，线程才失去控制权。
在多核CPU中，每个CPU运行一个线程，所以同时可以运行多个线程，真正并行。如果线程数多于CPU数，调度器依然采用时间片机制。




----------

[https://blog.csdn.net/hong10086/article/details/81633669](https://blog.csdn.net/hong10086/article/details/81633669 "CPU个数，核心数，线程数")
		 
[https://blog.csdn.net/qq_33530388/article/details/62448212](https://blog.csdn.net/qq_33530388/article/details/62448212 "CPU核心数目 与 多线程")

> 多线程实际上是计算机多种资源的并行运用，跟CPU有几个核心是没什么关系的。

[https://blog.csdn.net/wutongyuWxc/article/details/78732287](https://blog.csdn.net/wutongyuWxc/article/details/78732287 "cpu个数、核数、线程数、Java多线程关系的理解")
		
一 cpu个数、核数、线程数的关系

cpu个数：是指物理上，也及硬件上的核心数；

核数：是逻辑上的，简单理解为逻辑上模拟出的核心数；

线程数：是同一时刻设备能并行执行的程序个数，线程数=cpu个数 * 核数【如果有超线程，再乘以超线程数】
		 
[https://blog.csdn.net/qq_33290787/article/details/51790605](https://blog.csdn.net/qq_33290787/article/details/51790605 "多线程 ---并发与并行概念总结")

[https://juejin.im/post/5a98c2df6fb9a028b77a3fcf](https://juejin.im/post/5a98c2df6fb9a028b77a3fcf "操作系统多线程调度")