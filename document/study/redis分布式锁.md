> 1.应对并发场景

避免操作数据不一致 将对redis加锁 

> 2.考虑到异常状况无法释放锁，导致死锁

将代码块进行try-catch处理

> 3.考虑try时宕机依然导致死锁

对锁添加时效性，添加过期时间

> 4.由于业务代码块执行时长不确定，可能导致锁的永久时效

### 场景说明: ###

	  当业务1执行时，由于锁超时而失去了锁
      这时业务2进来任然继续执行，
      当业务2在执行时，业务1执行完毕，删除了业务2的锁，
      这时业务3进行任然继续执行
      重复上述步骤则导致锁的永久实效

### 解决方案 ###

	添加锁时生成唯一标识，使得业务n只能删除业务n所加的锁 

> 5.考虑到业务1超时，业务2任可继续执行的情况

可在代码块中开一个子线程，动态的更新有效时长-简称续命

> 6.主从问题

### 场景说明: ###

	当业务1添加锁时，主表添加了锁，从表尚未添加锁，此时主表宕机，从表替换掉主表，此时也会导致锁失效

### 解决思路： ###

	在添加锁时，维护主从的一致性，要么同时有，要么同时不存在。


----------
> 补充

1-5相关框架：redisson

----------
author:monster

since:5/7/2019 12:05:42 PM 

direction:redis 
