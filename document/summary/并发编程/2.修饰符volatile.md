
## 修饰符volatile ##

在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：

1. 原子性


		原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

2. 可见性

		可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

3. 有序性

		有序性：即程序执行的顺序按照代码的先后顺序执行。


----------

在程序中，我们的对象、变量都存储在主内存中

在单线程中，我们操作这些资源，并不会有什么问题。

而在多线程中，每个线程都拥有自己的线程内存(本地内存)，当我们对这些资源进行修改时，是先修改线程资源再同步到本地内存，即线程操作并不会第一时间同步到本地内存

此时，若存在多个线程操作同一资源，由于线程内存的存在，则会导致数据不一致

既然不一致，那加锁同步不就可以了？

对，这是一种解决方案，而volatile则是另一种解决方案

> volatile是Java提供的一种轻量级的同步机制，在并发编程中，它也扮演着比较重要的角色。
> 同synchronized相比（synchronized通常称为重量级锁），volatile更轻量级，相比使用synchronized所带来的庞大开销，
> 倘若能恰当的合理的使用volatile，自然是美事一桩。

先看下volatile的特性：

	1. 当写一个volatile变量时,会把该线程对应的本地内存的变量强制刷新到主内存
	2. 当进行写操作时，会导致其他线程的缓存无效

volatile是否可以替代lock?


> 这两个关键字在某些内存语义上有共通之处，volatile并不能完全替代synchronized，它依然是个轻量级锁，在很多场景下，volatile并不能胜任。

> 小心复合操作

	例如：num++;//自加操作 
	使用此操作在多线程先会导致结果比预料的更小
	因为num++不是个原子性的操作，而是复合操作
		1. 读取
		2. 加一
		3. 赋值

	所以，在多线程环境下，有可能线程A将num读取到本地内存中，此时其他线程可能已经将num增大了很多，线程A依然对过期的num进行自加，重新写到主存中，最终导致了num的结果不合预期
	


> 解决num++操作的原子性

	针对num++操作的原子性，可使用并发包中的Interlocked进行操作(实际使用CAS的方式保证其原子性)

> 禁止指令重排序

	volatile还有一个特性：禁止指令重排序优化。

	重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。

	(在内存模型中可了解关于重排序的知识)

> 如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

> volatile可以保证一定的有序性，但无法保证原子性。

----------

[https://www.cnblogs.com/chengxiao/p/6528109.html](https://www.cnblogs.com/chengxiao/p/6528109.html "谈谈Java中的volatile")

----------
author:monster 

since:5/20/2019 12:00:11 PM 

direction: 修饰符volatile