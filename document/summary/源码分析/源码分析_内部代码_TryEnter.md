
> source: Monitor

		
Ëé∑ÂèñÊåáÂÆöÂØπË±°ÁöÑÁã¨Âç†ÈîÅ„ÄÇ

	[MethodImpl(MethodImplOptions.InternalCall), SecuritySafeCritical, __DynamicallyInvokable]
	public static extern void Enter(object obj);

> src/vm/ecall.cpp

	FCFuncStart(gMonitorFuncs)
	    FCFuncElement("Enter", JIT_MonEnter)
	    FCFuncElement("Exit", JIT_MonExit)
	    FCFuncElement("TryEnterTimeout", JIT_MonTryEnter)
	    FCFuncElement("ObjWait", ObjectNative::WaitTimeout)
	    FCFuncElement("ObjPulse", ObjectNative::Pulse)
	    FCFuncElement("ObjPulseAll", ObjectNative::PulseAll)
	    FCFuncElement("ReliableEnter", JIT_MonReliableEnter)
	FCFuncEnd()

next -> JIT_MonEnter

> clr/src/vm/jithelpers.cpp

	HCIMPL2(FC_BOOL_RET, JIT_MonTryEnter_Portable, Object* obj, INT32 timeOut)
	{
	     CONTRACTL {
	         SO_TOLERANT;
	         THROWS;
	         DISABLED(GC_TRIGGERS);      // currently disabled because of FORBIDGC in HCIMPL
	    } CONTRACTL_END;
	
	#if !defined(_X86_) && !defined(_AMD64_)
	    {
			//aware
			//adj. ÊÑèËØÜÂà∞ÁöÑÔºõÁü•ÈÅìÁöÑÔºõÊúâ‚Ä¶ÊñπÈù¢Áü•ËØÜÁöÑÔºõÊáÇ‰∏ñÊïÖÁöÑ
			//n. (Aware)‰∫∫ÂêçÔºõ(ÈòøÊãâ‰ºØ„ÄÅÁ¥¢)ÈòøÁì¶Èõ∑
	        AwareLock* awareLock = NULL; 
	        SyncBlock* syncBlock = NULL;//ÂêåÊ≠•Á¥¢ÂºïÂùó
	        ObjHeader* objHeader = NULL;//ÂØπË±°Â§¥ *:ÂºïÁî®
	        LONG state,
			oldvalue;
	        DWORD tid;// DWORD Ê≠£‰Ωì : Âõõ‰ΩçÂÖÉÁªÑ [ÁîµÂ≠êËÆ°ÁÆóÊú∫] 
	        int spincount = 50;// spin - ÊóãËΩ¨ 
	        const int MaxSpinCount = 20000 * g_SystemInfo.dwNumberOfProcessors;
	       
	        Thread *pThread = GetThread();
	
	        if (pThread->IsAbortRequested()) //‰∏∫‰∏≠Ê≠¢Á∫øÁ®ã
	        {
	            goto FramedLockHelper;
	        }
	
	        if ((NULL == obj) || (timeOut < -1))//ÂèÇÊï∞‰∏çÊ≠£Á°Æ
	        {
	            goto FramedLockHelper;
	        }
	
	        tid = pThread->GetThreadId();//Ëé∑ÂèñÁ∫øÁ®ãid
	        objHeader = obj->GetHeader();//Ëé∑ÂèñÂØπË±°Â§¥
	
	        while (true)
	        {
				//Ëé∑ÂèñÂêåÊ≠•Á¥¢ÂºïÂùóÁöÑÂÄº
				//‰ªéÊ≠§Ê¨°ÂèØ‰ª•ÁúãÂá∫ÂêåÊ≠•Á¥¢ÂºïÂùóÁöÑÂÄºÂΩ±ÂìçÁùÄlock
	            oldvalue = objHeader->m_SyncBlockValue;
	            
	            if ((oldvalue & (BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX + 
	                            BIT_SBLK_SPIN_LOCK + 
	                            SBLK_MASK_LOCK_THREADID + 
	                            SBLK_MASK_LOCK_RECLEVEL)) ==0)//ÁªèËøáËÆ°ÁÆóÁªìÊûúËã•‰∏∫0ÂàôË°®Á§∫Âç≥Ê≤°ÊúâÈîÅ.
	            {       
	                
	                if (tid > SBLK_MASK_LOCK_THREADID)//Ë∂ÖËøáSBLKÊé©Á†ÅÈîÅÂÆö
	                {
	                    goto FramedLockHelper;
	                }
	                
	                LONG newvalue = oldvalue | tid;
	                if (FastInterlockCompareExchangeAcquire((LONG*)&(objHeader->m_SyncBlockValue), newvalue, oldvalue) == oldvalue)//Êõ¥Êñ∞ÂêåÊ≠•Á¥¢ÂºïÂùó ÁöÑÂÄº
	                {
	                    pThread->IncLockCount();//ÂÆûÈôÖÊìç‰ΩúÔºö m_dwLockCount ++;
	                    FC_RETURN_BOOL(TRUE);//Áõ¥Êé•ËøîÂõû
	                }
	                continue;
	            }
	
				//Â¶ÇÊûúÂ∑≤Â≠òÂú®ÂÄºÔºå‰∏î‰∏∫hashÊàñÂêåÊ≠•Á¥¢ÂºïÂùó‰∏ãÊ†á„ÄÇ
				//üò¢ËøôÈáåÂ∫îËØ•ËØ¥Êòé‰∫Ü‰∏§‰∏™ÁÇπ
				//	1. Â≠òÂú®ÂêåÊ≠•Á¥¢ÂºïÂùóË°® [ÈÄöËøá‰∏ãÊ†áËé∑Âèñ]
				//  2. ÂêåÊ≠•Á¥¢ÂºïÂùóÂèØ‰ª•‰ΩúÁî®‰∫éhashcode ‰∏é lockÈîÅ
	            if (oldvalue & BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX)
	            {
	                goto HaveHashOrSyncBlockIndex;
	            }
	
	            if (oldvalue & BIT_SBLK_SPIN_LOCK)
	            {
	                if (1 == g_SystemInfo.dwNumberOfProcessors)
	                {                
	                    goto FramedLockHelper;
	                }
	            }
	            else if (tid == (DWORD) (oldvalue & SBLK_MASK_LOCK_THREADID))
	            {
	                LONG newvalue = oldvalue + SBLK_LOCK_RECLEVEL_INC;
	                
	                if ((newvalue & SBLK_MASK_LOCK_RECLEVEL) == 0)
	                {
	                    goto FramedLockHelper;
	                }
	                
	                if (FastInterlockCompareExchangeAcquire((LONG*)&(objHeader->m_SyncBlockValue), newvalue, oldvalue) == oldvalue)
	                {
	                    FC_RETURN_BOOL(TRUE);
	                }
	            }
	            else
	            {
	                // lock is held by someone else
	                if (0 == timeOut)
	                {
	                    FC_RETURN_BOOL(FALSE);
	                }
	                else 
	                {
	                    goto FramedLockHelper;
	                }
	            }
	
	            // exponential backoff
	            for (int i = 0; i < spincount; i++)
	            {
	                YieldProcessor();//Êó†Êìç‰Ωú
	            }
	            if (spincount > MaxSpinCount)
	            {
	                goto FramedLockHelper;
	            }
	            spincount *= 3;
	        } /* while(true) */
	
	    HaveHashOrSyncBlockIndex:
	        if (oldvalue & BIT_SBLK_IS_HASHCODE)
	        {
	            goto FramedLockHelper;
	        }
	
	        syncBlock = obj->PassiveGetSyncBlock();
	        if (NULL == syncBlock)
	        {
	            goto FramedLockHelper;
	        }
	        
	        awareLock = syncBlock->QuickGetMonitor(); ‚ú®
	        state = awareLock->m_MonitorHeld; ‚ú® 
	        if (state == 0)
	        {
	            if (FastInterlockCompareExchangeAcquire((LONG*)&(awareLock->m_MonitorHeld), 1, 0) == 0)//ËøõË°åCASÊìç‰Ωú
	            {
	                syncBlock->SetAwareLock(pThread,1);‚ú®
	                pThread->IncLockCount();
	                FC_RETURN_BOOL(TRUE);
	            }
	            else
	            {
	                goto FramedLockHelper;
	            }
	        }
	        else if (awareLock->GetOwningThread() == pThread) /* monitor is held, but it could be a recursive case */
	        {
	            awareLock->m_Recursion++;//Âæ™ÁéØ+1
	            FC_RETURN_BOOL(TRUE);
	        }            
	FramedLockHelper: ;//üò¢ÂèÇÊï∞Ê£ÄÈ™åÂπ∂ËøîÂõûÁªìÊûú
	    }
	#endif // !_X86_ && !_AMD64_
	
	    BOOL result = FALSE;
	
	    OBJECTREF objRef = ObjectToOBJECTREF(obj);
	
	    // The following makes sure that Monitor.TryEnter shows up on thread
	    // abort stack walks (otherwise Monitor.TryEnter called within a CER can
	    // block a thread abort for long periods of time). Setting the __me internal
	    // variable (normally only set for fcalls) will cause the helper frame below
	    // to be able to backtranslate into the method desc for the Monitor.TryEnter
	    // fcall.
	    __me = GetEEFuncEntryPointMacro(JIT_MonTryEnter);
	
	    // Monitor helpers are used as both hcalls and fcalls, thus we need exact depth.
	    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_1(Frame::FRAME_ATTR_EXACT_DEPTH, objRef);
	
	    if (objRef == NULL)
	        COMPlusThrow(kArgumentNullException);
	
	    if (timeOut < -1)
	        COMPlusThrow(kArgumentException);
	
	    result = objRef->TryEnterObjMonitor(timeOut);‚ú®
	
	    HELPER_METHOD_FRAME_END();
	
	    FC_RETURN_BOOL(result);
	}
	HCIMPLEND



> Ë∑üË∏™ awareLock = syncBlock->QuickGetMonitor(); ‚ú®

> clr/src/vm/syncblk.h

	AwareLock* QuickGetMonitor()
    {
        LEAF_CONTRACT;
    // Note that the syncblock isn't marked precious, so use caution when
    // calling this method.
        return &m_Monitor;
    }

Áõ¥Êé•ËøîÂõû &m_Monitor

Ëøô‰∏™m_MonitorÂú®SyncBlockÁ±ª‰∏≠ÁöÑÂÆö‰πâÔºö

	protected: 
	   AwareLock  m_Monitor;                    // the actual monitor

ÊâÄ‰ª•ËØ¥ Â∞±ÊòØËé∑Âèñ‰∫Ü‰∏Ä‰∏™AwareLockÁöÑÂØπË±°


> state = awareLock->m_MonitorHeld; ‚ú®
> 
> clr/src/vm/syncblk.h
>  
	
	public:
	    volatile LONG   m_MonitorHeld;
	    ULONG           m_Recursion;
	    PTR_Thread      m_HoldingThread;
	    
	  private:
	    LONG            m_TransientPrecious;
	
	
	    // This is a backpointer from the syncblock to the synctable entry.  This allows
	    // us to recover the object that holds the syncblock.
	    DWORD           m_dwSyncIndex;
	
	    CLREvent        m_SemEvent;
	
	    // Only SyncBlocks can create AwareLocks.  Hence this private constructor.
	    AwareLock(DWORD indx)
	        : m_MonitorHeld(0),
	          m_Recursion(0),
	#ifndef DACCESS_COMPILE          
	// PreFAST has trouble with intializing a NULL PTR_Thread.
	          m_HoldingThread(NULL),
	#endif // DACCESS_COMPILE          
	          m_TransientPrecious(0),
	          m_dwSyncIndex(indx)
	    {
	        LEAF_CONTRACT;
	    }

Êü•ÁúãÂÆö‰πâÂè™ÊúâÂàùÂßãÁä∂ÊÄÅ‰∏∫0 ÊâÄ‰ª• m_MonitorHeldÂ∫îËØ•ÊòØÁî®Êù•ÂÅöCASÁöÑÁõ∏ÂÖ≥ÂèòÈáè

>  syncBlock->SetAwareLock(pThread,1);

> clr/src/vm/syncblk.h Êü•ÁúãÊñπÊ≥ïÂÆö‰πâÔºö

	void SetAwareLock(Thread *holdingThread, DWORD recursionLevel)
    {
        LEAF_CONTRACT;
        // <NOTE>
        // DO NOT SET m_MonitorHeld HERE!  THIS IS NOT PROTECTED BY ANY LOCK!!
        // </NOTE>
        m_Monitor.m_HoldingThread = PTR_Thread(holdingThread);
        m_Monitor.m_Recursion = recursionLevel;
    }

‰ªéÊ∫êÁ†ÅÂèØ‰ª•ÁúãÂá∫SetAwareLockÂ∞±ÊòØÁªôm_MonitorËøõË°åËµãÂÄºÔºåËÆ©m_MonitorÁöÑÁ∫øÁ®ãÊåáÂêëÂΩìÂâçÁ∫øÁ®ã ‰∏î Âæ™ÁéØÊ¨°Êï∞‰∏∫1

> awareLock->GetOwningThread()

üò¢Â∫îËØ•Â∞±ÊòØËé∑Âèñm_MonitorÁöÑm_HoldingThread


> result = objRef->TryEnterObjMonitor(timeOut);

> clr/src/vm/object.h

> Êü•ÁúãObjectÁöÑTryEnterObjMonitorÂÆö‰πâÔºö

 	BOOL TryEnterObjMonitor(INT32 timeOut = 0)
    {
        WRAPPER_CONTRACT;
        return GetHeader()->TryEnterObjMonitor(timeOut);
    }

Ë∞ÉÁî®‰∫ÜËØ∑Ê±ÇÂ§¥ÁöÑTryEnterObjMonitor

> clr/src/vm/syncblk.cpp

> Êü•ÁúãObjHeaderÁöÑTryEnterObjMonitorÊñπÊ≥ïÂÆö‰πâÔºö

	BOOL ObjHeader::TryEnterObjMonitor(INT32 timeOut)
	{
	    WRAPPER_CONTRACT;
	    return GetSyncBlock()->TryEnterMonitor(timeOut);
	}

Ë∞ÉÁî®‰∫ÜÂêåÊ≠•Á¥¢ÂºïÂùóÁöÑTryEnterMonitor

> clr/src/vm/syncblk.h

	BOOL TryEnterMonitor(INT32 timeOut = 0)
    {TryEnter
        WRAPPER_CONTRACT;
        return m_Monitor.TryEnter(timeOut);
    }

‰πãÂâçÂ∑≤ÁªèÁü•ÈÅì‰∫Üm_MonitorÂ∞±ÊòØË°®Á§∫AwareLock

ÂÜçÂà∞AwareLockÁöÑTryEnterÔºö

	BOOL AwareLock::TryEnter(INT32 timeOut)
	{
	    CONTRACTL
	    {
	        INSTANCE_CHECK;
	        THROWS;
	        GC_TRIGGERS;
	        MODE_ANY;
	        INJECT_FAULT(COMPlusThrowOM(););
	    }
	    CONTRACTL_END;
	
	    if (timeOut != 0)
	    {
	        LARGE_INTEGER qpFrequency, qpcStart, qpcEnd;
	        BOOL canUseHighRes = QueryPerformanceCounter(&qpcStart);
	
	        // try some more busy waiting
	        if (Contention(timeOut))
	            return TRUE;
	
	        DWORD elapsed = 0;
	        if (canUseHighRes && QueryPerformanceCounter(&qpcEnd) && QueryPerformanceFrequency(&qpFrequency))
	            elapsed = (DWORD)((qpcEnd.QuadPart-qpcStart.QuadPart)/(qpFrequency.QuadPart/1000));
	
	        if (elapsed >= (DWORD)timeOut)
	            return FALSE;
	
	        if (timeOut != (INT32)INFINITE)
	            timeOut -= elapsed;
	    }
	
	    Thread  *pCurThread = GetThread();
	    TESTHOOKCALL(AppDomainCanBeUnloaded(pCurThread->GetDomain()->GetId().m_dwId,FALSE));    
	
	    if (pCurThread->IsAbortRequested()) 
	    {
	        pCurThread->HandleThreadAbort();
	    }
	
	retry:
	    for (;;) {
	
	        // Read existing lock state.
	        LONG state = m_MonitorHeld;
	
	        if (state == 0) //ÂàùÂßãÊó†ÈîÅÁä∂ÊÄÅ
	        {
	            // Common case: lock not held, no waiters. Attempt to acquire lock by
	            // switching lock bit.
	            if (FastInterlockCompareExchange((LONG*)&m_MonitorHeld, 1, 0) == 0)
	            {
	                break;
	            }
	
	        } 
	        else 
	        {
	            // It's possible to get here with waiters but no lock held, but in this
	            // case a signal is about to be fired which will wake up a waiter. So
	            // for fairness sake we should wait too.
	            // Check first for recursive lock attempts on the same thread.
	            if (m_HoldingThread == pCurThread)//ÂΩìÂâçÁ∫øÁ®ã‰∏∫ÈîÅÁ∫øÁ®ã
	            {
	                goto Recursion;
	            }
	            else
	            {
	                goto WouldBlock;
	            }
	        }
	
	    }
	
	    // We get here if we successfully acquired the mutex.
	    m_HoldingThread = pCurThread;
	    m_Recursion = 1;
	    pCurThread->IncLockCount();
	
	#if defined(_DEBUG) && defined(TRACK_SYNC)
	    {
	        // The best place to grab this is from the ECall frame
	        Frame   *pFrame = pCurThread->GetFrame();
	        int      caller = (pFrame && pFrame != FRAME_TOP ? (int) pFrame->GetReturnAddress() : -1);
	        pCurThread->m_pTrackSync->EnterSync(caller, this);
	    }
	#endif
	
	    return true;
	
	WouldBlock:
	    // Didn't manage to get the mutex, return failure if no timeout, else wait
	    // for at most timeout milliseconds for the mutex.
	    if (!timeOut)
	    {
	        return false;
	    }
	
	    // The precondition for EnterEpilog is that the count of waiters be bumped
	    // to account for this thread
	    for (;;)
	    {
	        // Read existing lock state.
	        volatile LONG state = m_MonitorHeld;
	        if (state == 0)
	        {
	            goto retry;
	        }
	        if (FastInterlockCompareExchange((LONG*)&m_MonitorHeld, (state + 2), state) == state)
	        {
	            break;
	        }
	    }
	    return EnterEpilog(pCurThread, timeOut);
	
	Recursion:
	    // Got the mutex via recursive locking on the same thread.
	    _ASSERTE(m_Recursion >= 1);
	    m_Recursion++;
	#if defined(_DEBUG) && defined(TRACK_SYNC)
	    // The best place to grab this is from the ECall frame
	    Frame   *pFrame = pCurThread->GetFrame();
	    int      caller = (pFrame && pFrame != FRAME_TOP ? (int) pFrame->GetReturnAddress() : -1);
	    pCurThread->m_pTrackSync->EnterSync(caller, this);
	#endif
	
	    return true;
	}


ÂÜçÂõûÂà∞ObjHeaderÁöÑGetSyncBlock()

	//Ëé∑ÂèñÁé∞ÊúâÂØπË±°ÁöÑÂêåÊ≠•Âùó
	// get the sync block for an existing object
	SyncBlock *ObjHeader::GetSyncBlock()
	{
	    CONTRACT(SyncBlock *)
	    {
	        INSTANCE_CHECK;
	        THROWS;
	        GC_NOTRIGGER;
	        MODE_ANY;
	        INJECT_FAULT(COMPlusThrowOM(););
	        POSTCONDITION(CheckPointer(RETVAL));
	    }
	    CONTRACT_END;
	
	    SyncBlock* syncBlock = GetBaseObject()->PassiveGetSyncBlock(); ‚ú®
	    DWORD      indx = 0;
	    BOOL indexHeld = FALSE;
	
	    if (syncBlock)
	    {
	        // Has our backpointer been correctly updated through every GC?
	        _ASSERTE(SyncTableEntry::GetSyncTableEntry()[GetHeaderSyncBlockIndex()].m_Object == GetBaseObject());
	        RETURN syncBlock;
	    }
	
		//ÈúÄË¶Å‰ªéÁºìÂ≠ò‰∏≠Ëé∑ÂèñÂÆÉ
	    //Need to get it from the cache
	    {
	        SyncBlockCache::LockHolder lh(SyncBlockCache::GetSyncBlockCache());
	
	        //Try one more time
	        syncBlock = GetBaseObject()->PassiveGetSyncBlock();
	        if (syncBlock)
	            RETURN syncBlock;
	
	
	        SyncBlockMemoryHolder syncBlockMemoryHolder(SyncBlockCache::GetSyncBlockCache()->GetNextFreeSyncBlock());
	        syncBlock = syncBlockMemoryHolder;
	
	        if ((indx = GetHeaderSyncBlockIndex()) == 0)
	        {
	            indx = SyncBlockCache::GetSyncBlockCache()->NewSyncBlockSlot(GetBaseObject());
	        }
	        else
	        {
	            //We already have an index, we need to hold the syncblock
	            indexHeld = TRUE;
	        }
	
	        {
	            //! NewSyncBlockSlot has side-effects that we don't have backout for - thus, that must be the last
	            //! failable operation called.
	            CANNOTTHROWCOMPLUSEXCEPTION();
	            FAULT_FORBID();
	
	
	            syncBlockMemoryHolder.SuppressRelease();
	
	            new (syncBlock) SyncBlock(indx);
	
	            // after this point, nobody can update the index in the header to give an AD index
	            EnterSpinLock();
	
	            {
	                // If there's an appdomain index stored in the header, transfer it to the syncblock
	
	                ADIndex dwAppDomainIndex = GetAppDomainIndex();
	                if (dwAppDomainIndex.m_dwIndex)
	                    syncBlock->SetAppDomainIndex(dwAppDomainIndex);
	
	                // If the thin lock in the header is in use, transfer the information to the syncblock
	                DWORD bits = GetBits();
	                if ((bits & BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX) == 0)
	                {
	                    DWORD lockThreadId = bits & SBLK_MASK_LOCK_THREADID;
	                    DWORD recursionLevel = (bits & SBLK_MASK_LOCK_RECLEVEL) >> SBLK_RECLEVEL_SHIFT;
	                    if (lockThreadId != 0 || recursionLevel != 0)
	                    {
	                        // recursionLevel can't be non-zero if thread id is 0
	                        _ASSERTE(lockThreadId != 0);
	
	                        Thread *pThread = g_pThinLockThreadIdDispenser->IdToThreadWithValidation(lockThreadId);
	
	                        if (pThread == NULL)
	                        {
	                            // The lock is orphaned.
	                            pThread = (Thread*) -1;
	                        }
	                        syncBlock->InitState();
	                        syncBlock->SetAwareLock(pThread, recursionLevel + 1);
	                    }
	                }
	                else if ((bits & BIT_SBLK_IS_HASHCODE) != 0)
	                {
	                    DWORD hashCode = bits & MASK_HASHCODE;
	
	                    syncBlock->SetHashCode(hashCode);
	                }
	            }
	
	            SyncTableEntry::GetSyncTableEntry() [indx].m_SyncBlock = syncBlock;
	
	            // in order to avoid a race where some thread tries to get the AD index and we've already nuked it,
	            // make sure the syncblock etc is all setup with the AD index prior to replacing the index
	            // in the header
	            if (GetHeaderSyncBlockIndex() == 0)
	            {
	                // We have transferred the AppDomain into the syncblock above.
	                SetIndex(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | indx);
	            }
	
	            //If we had already an index, hold the syncblock
	            //for the lifetime of the object.
	            if (indexHeld)
	                syncBlock->SetPrecious();
	
	            ReleaseSpinLock();
	
	            // SyncBlockCache::LockHolder goes out of scope here
	        }
	    }
	
	    RETURN syncBlock;
	}

ÂÖàÁúã SyncBlock* syncBlock = GetBaseObject()->PassiveGetSyncBlock();

> clr/src/vm/syncblk.h

	Object *GetBaseObject()
    {
        LEAF_CONTRACT;
        return (Object *) (this + 1);
    }

ÂÖàËøîÂõû‰∫ÜObject

ÁªßÁª≠Êü•ÁúãPassiveGetSyncBlock

	//Ê£ÄÁ¥¢ÂêåÊ≠•ÂùóÔºå‰ΩÜ‰∏çÂàÜÈÖç 
	 // retrieve sync block but don't allocate
	    SyncBlock *PassiveGetSyncBlock()
	    {
	#ifndef DACCESS_COMPILE
	        LEAF_CONTRACT;
	
	        return g_pSyncTable [GetHeaderSyncBlockIndex()].m_SyncBlock;
	#else
	        DacNotImpl();
	        return NULL;
	#endif // !DACCESS_COMPILE
	    }

g_pSyncTable Ê≠§Â§Ñ‰πüËØÅÂÆû‰∫Ü ÂêåÊ≠•Á¥¢ÂºïÂùóË°®ÁöÑÂ≠òÂú®

ÂêåÊ≠•Á¥¢ÂºïÂùóÂêéÁª≠ÂÜçÊù•ËøΩË∏™...

----------
### confirm ###

	Every Object is preceded by an ObjHeader (at a negative offset).
	ÊØè‰∏™ÂØπË±°ÂâçÈù¢ÈÉΩÊúâ‰∏Ä‰∏™ObjHeader(Ë¥üÂÅèÁßªÈáè)„ÄÇ
	 The
	ÁöÑ
	 ObjHeader has an index to a SyncBlock.
	ObjHeaderÊúâ‰∏Ä‰∏™ÊåáÂêëÂêåÊ≠•ÂùóÁöÑÁ¥¢Âºï„ÄÇ
	 This index is 0 for the bulk of all
	Â§ßÂ§öÊï∞ÊÉÖÂÜµ‰∏ãÔºåËøô‰∏™ÊåáÊï∞ÊòØ0
	 instances, which indicates that the object shares a dummy SyncBlock with
	ÂÆû‰æãÔºåÂÆÉÊåáÁ§∫ÂØπË±°‰∏é‰∏Ä‰∏™ËôöÊãüÂêåÊ≠•ÂùóÂÖ±‰∫´‰∏Ä‰∏™ÂêåÊ≠•Âùó
	 most other objects.
	Â§ßÂ§öÊï∞ÂÖ∂‰ªñÂØπË±°„ÄÇ
	 The SyncBlock is primarily responsible for object synchronization.
	SyncBlock‰∏ªË¶ÅË¥üË¥£ÂØπË±°ÂêåÊ≠•„ÄÇ
	 However,
	ÁÑ∂ËÄå,
	 it is also a "kitchen sink" of sparsely allocated instance data.
	ÂÆÉ‰πüÊòØ‰∏Ä‰∏™Áî±Á®ÄÁñèÂàÜÈÖçÁöÑÂÆû‰æãÊï∞ÊçÆÁªÑÊàêÁöÑ‚ÄúÂé®ÊàøÊ∞¥ÊßΩ‚Äù„ÄÇ
	 For instance,
	‰æãÂ¶Ç,
	 the default implementation of Hash() is based on the existence of a SyncTableEntry.
	Hash()ÁöÑÈªòËÆ§ÂÆûÁé∞Âü∫‰∫éSyncTableEntryÁöÑÂ≠òÂú®„ÄÇ
	 And objects exposed to or from COM, or through context boundaries, can store sparse
	Êö¥Èú≤‰∫éCOMÊàñÊù•Ëá™COMÊàñÈÄöËøá‰∏ä‰∏ãÊñáËæπÁïåÁöÑÂØπË±°ÂèØ‰ª•Á®ÄÁñèÂ≠òÂÇ®
	 data here.
	ËøôÈáåÁöÑÊï∞ÊçÆ„ÄÇ
	 SyncTableEntries and SyncBlocks are allocated in non-GC memory.
	ÂêåÊ≠•Ë°®È°πÂíåÂêåÊ≠•ÂùóÂàÜÈÖçÂú®ÈùûgcÂÜÖÂ≠ò‰∏≠„ÄÇ
	 A weak pointer
	‰∏Ä‰∏™Âº±ÊåáÈíà
	 from the SyncTableEntry to the instance is used to ensure that the SyncBlock and
	‰ªéSyncTableEntryÂà∞ÂÆû‰æãÔºåÁî®‰∫éÁ°Æ‰øùSyncBlockÂíå
	 SyncTableEntry are reclaimed (recycled) when the instance dies.
	SyncTableEntryÂú®ÂÆû‰æãÊ≠ªÂêéË¢´ÂõûÊî∂(ÂõûÊî∂)„ÄÇ
	 The organization of the SyncBlocks isn't intuitive (at least to me).
	ÂêåÊ≠•ÂùóÁöÑÁªÑÁªáÂπ∂‰∏çÁõ¥ËßÇ(Ëá≥Â∞ëÂØπÊàëÊù•ËØ¥ÊòØËøôÊ†∑)„ÄÇ
	 Here's
	ËøôÊòØ
	 the explanation:
	Ëß£Èáä:
	 Before each Object is an ObjHeader.
	ÊØè‰∏™ÂØπË±°‰πãÂâçÈÉΩÊúâ‰∏Ä‰∏™ObjHeader„ÄÇ
	 If the object has a SyncBlock, the
	Â¶ÇÊûúÂØπË±°ÊúâÂêåÊ≠•ÂùóÔºåÂàô
	 ObjHeader contains a non-0 index to it.
	ObjHeaderÂåÖÂê´‰∏Ä‰∏™Èùû0Á¥¢Âºï„ÄÇ
	 The index is looked up in the g_pSyncTable of SyncTableEntries.
	Á¥¢ÂºïÂú®SyncTableEntriesÁöÑg_pSyncTable‰∏≠Êü•Êâæ„ÄÇ
	 This means
	ËøôÊÑèÂë≥ÁùÄ
	 the table is consecutive for all outstanding indices.
	ËØ•Ë°®ËøûÁª≠ÂàóÂá∫ÊâÄÊúâÊú™Ê∏ÖÂÅøÁöÑÊåáÊï∞„ÄÇ
	 Whenever it needs to
	Êó†ËÆ∫‰ΩïÊó∂ÈúÄË¶Å
	 grow, it doubles in size and copies all the original entries.
	Â¢ûÈïøÔºåÂÆÉÁöÑÂ§ßÂ∞èÁøªÂÄçÔºåÂ§çÂà∂ÊâÄÊúâÂéüÂßãÊù°ÁõÆ„ÄÇ
	 The old table
	ÊóßÁöÑË°®
	 is kept until GC time, when it can be safely discarded.
	‰øùÂ≠òÂà∞GCÊó∂Èó¥ÔºåÂú®GCÊó∂Èó¥ÂèØ‰ª•ÂÆâÂÖ®Âú∞‰∏¢ÂºÉÂÆÉ„ÄÇ
	 Each SyncTableEntry has a backpointer to the object and a forward pointer to
	ÊØè‰∏™SyncTableEntryÈÉΩÊúâ‰∏Ä‰∏™ÊåáÂêëËØ•ÂØπË±°ÁöÑÂèçÂêëÊåáÈíàÂíå‰∏Ä‰∏™ÊåáÂêëËØ•ÂØπË±°ÁöÑÊ≠£ÂêëÊåáÈíà
	 the actual SyncBlock.
	ÂÆûÈôÖÁöÑSyncBlock„ÄÇ
	 The SyncBlock is allocated out of a SyncBlockArray
	ÂêåÊ≠•ÂùóÊòØ‰ªéÂêåÊ≠•ÂùóÂ∞ÑÁ∫ø‰∏≠ÂàÜÈÖçÁöÑ
	 which is essentially just a block of SyncBlocks.
	Êú¨Ë¥®‰∏äÂ∞±ÊòØ‰∏ÄÁªÑÂêåÊ≠•Âùó„ÄÇ
	 The SyncBlockArrays are managed by a SyncBlockCache that handles the actual
	SyncBlockArraysÁî±‰∏Ä‰∏™SyncBlockCacheÁÆ°ÁêÜÔºåÂÆÉÂ§ÑÁêÜÂÆûÈôÖÁöÑ
	 allocations and frees of the blocks.
	ÂàÜÈÖçÂíåÈáäÊîæÂùó„ÄÇ
	 So...
	ÊâÄ‰ª•‚Ä¶
	 Each allocation and release has to handle free lists in the table of entries
	ÊØè‰∏™ÂàÜÈÖçÂíåÂèëÂ∏ÉÈÉΩÂøÖÈ°ªÂ§ÑÁêÜÊù°ÁõÆË°®‰∏≠ÁöÑÁ©∫Èó≤ÂàóË°®
	 and the table of blocks.
	ÂíåÁßØÊú®Ê°å„ÄÇ
	 We burn an extra 4 bytes for the pointer from the SyncTableEntry to the
	‰ªéSyncTableEntryÂà∞
	 SyncBlock.
	SyncBlock„ÄÇ
	 The reason for this is that many objects have a SyncTableEntry but no SyncBlock.
	ÂéüÂõ†ÊòØËÆ∏Â§öÂØπË±°ÈÉΩÊúâSyncTableEntryÔºå‰ΩÜÊ≤°ÊúâSyncBlock„ÄÇ
	 That's because someone (e.g. HashTable) called Hash() on them.
	ËøôÊòØÂõ†‰∏∫Êúâ‰∫∫(‰æãÂ¶ÇHashTable)ÂØπÂÆÉ‰ª¨Ë∞ÉÁî®‰∫ÜHash()„ÄÇ
	 Incidentally, there's a better write-up of all this stuff in the archives.
	È°∫‰æøËØ¥‰∏ÄÂè•ÔºåÂú®Ê°£Ê°àÈ¶ÜÈáåÊúâ‰∏Ä‰∏™Êõ¥Â•ΩÁöÑÂÖ≥‰∫éËøô‰∫õ‰∏úË•øÁöÑËÆ∞ÂΩï„ÄÇ

----------


### Áõ∏ÂÖ≥ÈìæÊé• ###

[https://github.com/SSCLI/sscli20_20060311](https://github.com/SSCLI/sscli20_20060311 "gitÂú∞ÂùÄ")

[https://www.codeproject.com/Articles/184046/Spin-Lock-in-C](https://www.codeproject.com/Articles/184046/Spin-Lock-in-C "ÊóãËΩ¨ÈîÅ")

[https://www.codeproject.com/Articles/18371/Fast-critical-sections-with-timeout](https://www.codeproject.com/Articles/18371/Fast-critical-sections-with-timeout "ÂêåÊ≠•")

----------
author:monster

since:5/16/2019 2:12:32 PM 

direction:Ê∫êÁ†ÅÂàÜÊûê_ÂÜÖÈÉ®‰ª£Á†Å_Enter-2