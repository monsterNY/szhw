
> 脏数据

	<wiki>从广义上看，脏数据是指没有进行过数据预处理而直接接收到的、处于原始状态的数据；
	从狭义上看，是不符合研究要求，以及不能够对其直接进行相应的数据分析。
	脏数据依据不同的分析目的有不同的定义，
	如在常见的数据挖掘工作中，脏数据是指不完整、含噪声、不一致的数据；
	而在问卷分析中，脏数据则是指不符合问卷要求的数据。

    <bky>脏读dirty reads：当事务读取还未被提交的数据时，就会发生这种事件。举例来说：  
	
		事务a  修改了一行数据，然后   
		事务b  在   
		事务a  还未提交修改操作之前读取了被修改的行。如果   
		事务a  回滚了修改操作，那么   
		事务b  读取的数据就可以看作是从未存在过的。  

    即 脏数据为还未进行保存的数据，即数据库中不存在的数据

## lock 锁 ##

> 1.事务中的锁

（1）SQL Server使用锁来实现事务的隔离。

（2）事务获取锁这种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。

 (3) 通过锁来确保在此次事务完成之前不会有其他事务会更改此事务需要操作的数据

> 2.锁模式

（1）排他锁

　　a.当试图修改数据时，事务只能为所依赖的数据资源请求排他锁。

　　b.持有排他锁时间：一旦某个事务得到了排他锁，则这个事务将一直持有排他锁直到事务完成。

　　c.排他锁和其他任何类型的锁在多事务中不能在同一阶段作用于同一个资源。

　　　　如：当前事务获得了某个资源的排他锁，则其他事务不能获得该资源的任何其他类型的锁。其他事务获得了某个资源的任何其他类型的锁，则当前事务不能获得该资源的排他锁。

（2）共享锁

　　a.当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁。

　　b.持有共享锁时间：从事务得到共享锁到读操作完成。

　　c.多个事务可以在同一阶段用共享锁作用于同一数据资源。

　　d.在读取数据时，可以对如何处理锁定进行控制。后面隔离级别会讲到如何对锁定进行控制。



> 3.排他锁和共享锁的兼容性

（1）如果数据正在由一个事务进行修改，则其他事务既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。

（2）如果数据正在由一个事务读取，则其他事务不能修改该数据（至少默认不能）。

> 4.可锁定的资源的类型

	RID、KEY（行）、PAGE（页）、对象（例如表）、数据库、EXTENT（区）、分配单元（ALLOCATION_UNIT）、堆（HEAP）、以及B树（B-tree）。
	RID: 标识页上的特定行
	　　格式: fileid: pagenumber: rid （1:109:0 ）
	　　　　其中fileid标识包含页的文件， pagenumber标识包含行的页，rid标识页上的特定行。
	　　　　fileid与sys.databases_files 目录视图中的file_id列相匹配
	　　例子：
	　　　　在查询视图sys.dm_tran_locks的时候有一行的resource_description列显示RID 是1:109:0 而status列显示wait,
	　　　　表示第1个数据文件上的第109页上的第0行上的锁资源。

> summary
> 
| IsoLevel        | 是否读取未提交的行|	是否不可重复读	|是否丢失更新|	是否幻读	|共享锁持续时间|	是否持有范围锁|
| ------------- |:-------------:|:-------------:|:-------------:|:-------------:|:-------------:| :-----:|
|    未提交读   | Y | Y  | Y |   Y    | 当前语句 | N |
|    已提交读  | N | Y  | Y |   Y    | 当前语句 | N |
|    可重复读  | N | N  | N |   Y    | 整个事务 | N |
|    可序列化   | N | N  | N |   N    | 整个事务 | Y |

可重复读不会出现丢失更新。。。

----------

[https://www.cnblogs.com/jackson0714/p/TSQLFundamentals_08.html](https://www.cnblogs.com/jackson0714/p/TSQLFundamentals_08.html "相关博文")

----------
author:monster

direction:lock

date:1/24/2019 3:12:07 PM 